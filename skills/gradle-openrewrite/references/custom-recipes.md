# Writing Custom OpenRewrite Recipes

## Overview

When standard OpenRewrite recipes don't cover your specific migration needs, you can create custom recipes. This guide covers declarative YAML recipes (easiest) and when to escalate to Java recipes.

## Declarative YAML Recipes

### Basic Structure

Create a `rewrite.yml` in your project root:

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.gradle.MyCustomMigration
displayName: My Custom Migration
description: Migrate our custom patterns
recipeList:
  - org.openrewrite.gradle.ChangeDependencyVersion:
      groupId: com.mycompany
      artifactId: old-library
      newVersion: 2.0.0
```

### Common Recipe Types

#### Change Method Names

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.RenameDeprecatedMethods
recipeList:
  - org.openrewrite.java.ChangeMethodName:
      methodPattern: "com.mycompany.OldClass oldMethod()"
      newMethodName: "newMethod"
```

#### Change Types

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.MigrateTypes
recipeList:
  - org.openrewrite.java.ChangeType:
      oldFullyQualifiedTypeName: "com.mycompany.DeprecatedService"
      newFullyQualifiedTypeName: "com.mycompany.NewService"
```

#### Change Dependencies

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.UpdateDependencies
recipeList:
  - org.openrewrite.gradle.ChangeDependencyGroupId:
      groupId: "com.oldcompany"
      artifactId: "*"
      newGroupId: "com.newcompany"

  - org.openrewrite.gradle.UpgradeDependencyVersion:
      groupId: "com.mycompany"
      artifactId: "core-lib"
      newVersion: "3.x"
```

#### Add Dependencies

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.AddRequiredDependencies
recipeList:
  - org.openrewrite.gradle.AddDependency:
      groupId: "org.slf4j"
      artifactId: "slf4j-api"
      version: "2.0.9"
      configuration: "implementation"
```

### Composite Recipes

Combine multiple recipes into a migration workflow:

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.FullMigration
displayName: Full Migration to v3
description: Complete migration from v2 to v3
recipeList:
  # First, update dependencies
  - com.mycompany.UpdateDependencies

  # Then, rename methods
  - com.mycompany.RenameDeprecatedMethods

  # Finally, update types
  - com.mycompany.MigrateTypes
```

## Gradle-Specific Patterns

### Migrate Task Configuration

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.MigrateTaskPatterns
recipeList:
  # Replace tasks.create with tasks.register
  - org.openrewrite.gradle.search.FindGradleProject
  # Note: Complex task migrations may need Java recipes
```

### Update Plugin Configuration

```yaml
type: specs.openrewrite.org/v1beta/recipe
name: com.mycompany.UpdatePluginConfig
recipeList:
  - org.openrewrite.gradle.plugins.ChangePlugin:
      pluginIdOld: "com.mycompany.old-plugin"
      pluginIdNew: "com.mycompany.new-plugin"
      newVersion: "2.0.0"
```

## Using Custom Recipes

### Option 1: Project-Local Recipe

Place `rewrite.yml` in your project root:

```bash
/openrewrite run com.mycompany.FullMigration
```

### Option 2: Shared Recipe Library

1. Create a separate project for recipes
2. Publish to Maven repository
3. Reference in configuration:

```yaml
# .claude/gradle-plugin.local.md
---
openrewrite:
  additionalRecipes:
    - "com.mycompany:custom-recipes:1.0.0"
---
```

## Recipe Generation

The plugin can generate custom recipes based on detected issues:

```bash
# Analyze project and generate recipes for uncovered patterns
/openrewrite generate-recipe

# Output: .rewrite/generated-migrations.yml
```

Example generated recipe:

```yaml
# Auto-generated by gradle-claude-plugin
type: specs.openrewrite.org/v1beta/recipe
name: com.generated.DetectedMigrations
displayName: Detected Migrations
description: Auto-generated recipe for project-specific patterns
recipeList:
  - org.openrewrite.java.ChangeMethodName:
      methodPattern: "com.myproject.BuildHelper getBuildDir()"
      newMethodName: "getLayoutBuildDirectory"
```

## When to Use Java Recipes

Declarative YAML recipes have limitations. Use Java recipes when you need:

- Complex conditional logic
- AST traversal and analysis
- Custom visitors
- State between transformations

### Java Recipe Example

```java
package com.mycompany.recipes;

import org.openrewrite.*;
import org.openrewrite.gradle.GradleVisitor;
import org.openrewrite.groovy.tree.G;

public class MigrateCustomTaskPattern extends Recipe {

    @Override
    public String getDisplayName() {
        return "Migrate Custom Task Pattern";
    }

    @Override
    public String getDescription() {
        return "Migrates tasks.create to tasks.register for custom patterns";
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getVisitor() {
        return new GradleVisitor<ExecutionContext>() {
            @Override
            public G.CompilationUnit visitCompilationUnit(
                    G.CompilationUnit cu, ExecutionContext ctx) {
                // Custom transformation logic
                return super.visitCompilationUnit(cu, ctx);
            }
        };
    }
}
```

## Testing Recipes

### Unit Testing

```java
import org.openrewrite.test.RewriteTest;
import static org.openrewrite.gradle.Assertions.buildGradle;

class MyRecipeTest implements RewriteTest {

    @Test
    void migratesOldPattern() {
        rewriteRun(
            spec -> spec.recipe(new MyCustomRecipe()),
            buildGradle(
                """
                tasks.create("myTask") {
                    // old pattern
                }
                """,
                """
                tasks.register("myTask") {
                    // new pattern
                }
                """
            )
        );
    }
}
```

### Dry Run Testing

```bash
# Always dry-run first
/openrewrite dry-run com.mycompany.MyCustomRecipe

# Review changes before applying
/openrewrite run com.mycompany.MyCustomRecipe
```

## Best Practices

1. **Start with dry-run**: Always preview changes first
2. **Use composite recipes**: Break complex migrations into steps
3. **Test thoroughly**: Unit test Java recipes
4. **Version your recipes**: Treat recipes as code
5. **Document patterns**: Explain what each recipe does
6. **Prefer declarative**: Use YAML when possible, Java when necessary

## Resources

- [OpenRewrite Recipe Authoring](https://docs.openrewrite.org/authoring-recipes)
- [Recipe Testing](https://docs.openrewrite.org/authoring-recipes/recipe-testing)
- [Gradle LST Reference](https://docs.openrewrite.org/concepts-explanations/lst-examples)
